"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Dashboard_Dashboard_jsx",{

/***/ "(app-pages-browser)/./src/utils/dataProcessor.js":
/*!************************************!*\
  !*** ./src/utils/dataProcessor.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFeatureImportance: function() { return /* binding */ calculateFeatureImportance; },\n/* harmony export */   createTarget: function() { return /* binding */ createTarget; },\n/* harmony export */   loadCsvFile: function() { return /* binding */ loadCsvFile; },\n/* harmony export */   parseCSV: function() { return /* binding */ parseCSV; },\n/* harmony export */   prepareTrainingData: function() { return /* binding */ prepareTrainingData; },\n/* harmony export */   processData: function() { return /* binding */ processData; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"(app-pages-browser)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst loadCsvFile = async (filePath)=>{\n    try {\n        const response = await fetch(filePath);\n        if (!response.ok) {\n            throw new Error(\"Failed to load \".concat(filePath));\n        }\n        const csvText = await response.text();\n        return parseCSV(csvText);\n    } catch (error) {\n        console.error(\"Error loading CSV file \".concat(filePath, \":\"), error);\n        throw error;\n    }\n};\nconst parseCSV = (csvText)=>{\n    const results = papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(csvText, {\n        header: true,\n        dynamicTyping: true,\n        skipEmptyLines: true\n    });\n    // Handle any parse errors\n    if (results.errors.length > 0) {\n        console.warn(\"CSV parsing had errors:\", results.errors);\n    }\n    return results.data;\n};\nconst prepareTrainingData = (trainData)=>{\n    // Convert date columns\n    const dateColumns = [\n        \"agent_join_month\",\n        \"first_policy_sold_month\",\n        \"year_month\"\n    ];\n    const processedData = trainData.map((row)=>{\n        const processedRow = {\n            ...row\n        };\n        // Convert date strings to Date objects\n        dateColumns.forEach((col)=>{\n            if (row[col]) {\n                processedRow[col] = new Date(row[col]);\n            }\n        });\n        return processedRow;\n    });\n    // Sort by agent_code and year_month\n    processedData.sort((a, b)=>{\n        const aCode = String(a.agent_code || \"\");\n        const bCode = String(b.agent_code || \"\");\n        if (aCode === bCode) {\n            return new Date(a.year_month || 0) - new Date(b.year_month || 0);\n        }\n        return aCode.localeCompare(bCode);\n    });\n    return processedData;\n};\nconst createTarget = (trainData)=>{\n    // Group by agent_code\n    const agentGroups = {};\n    trainData.forEach((row)=>{\n        if (!agentGroups[row.agent_code]) {\n            agentGroups[row.agent_code] = [];\n        }\n        agentGroups[row.agent_code].push(row);\n    });\n    // Sort each agent's data by year_month\n    Object.values(agentGroups).forEach((agentData)=>{\n        agentData.sort((a, b)=>new Date(a.year_month) - new Date(b.year_month));\n    });\n    // Create target variable (0 = NILL, 1 = non-NILL)\n    const dataWithTarget = [];\n    Object.values(agentGroups).forEach((agentData)=>{\n        for(let i = 0; i < agentData.length - 1; i++){\n            const currentRow = {\n                ...agentData[i]\n            };\n            const nextRow = agentData[i + 1];\n            // If they sell anything next month, target is 1 (non-NILL)\n            currentRow.target_column = nextRow.new_policy_count > 0 ? 1 : 0;\n            dataWithTarget.push(currentRow);\n        }\n    });\n    return dataWithTarget;\n};\nconst calculateFeatureImportance = (model)=>{\n    // Simulate feature importance based on model\n    // In a real implementation, this would come from your model\n    const baseFeatures = [\n        {\n            feature: \"unique_proposal\",\n            importance: 0.85\n        },\n        {\n            feature: \"unique_quotations\",\n            importance: 0.78\n        },\n        {\n            feature: \"unique_proposals_last_7_days\",\n            importance: 0.72\n        },\n        {\n            feature: \"unique_quotations_last_7_days\",\n            importance: 0.69\n        },\n        {\n            feature: \"agent_age\",\n            importance: 0.65\n        },\n        {\n            feature: \"months_with_company\",\n            importance: 0.62\n        },\n        {\n            feature: \"unique_customers\",\n            importance: 0.61\n        },\n        {\n            feature: \"unique_customers_last_7_days\",\n            importance: 0.59\n        },\n        {\n            feature: \"proposal_momentum\",\n            importance: 0.58\n        },\n        {\n            feature: \"quotation_conversion_rate\",\n            importance: 0.55\n        },\n        {\n            feature: \"unique_proposals_last_15_days\",\n            importance: 0.54\n        },\n        {\n            feature: \"unique_quotations_last_15_days\",\n            importance: 0.53\n        },\n        {\n            feature: \"hist_nill_rate\",\n            importance: 0.52\n        },\n        {\n            feature: \"hist_current_nill_streak\",\n            importance: 0.48\n        },\n        {\n            feature: \"months_to_first_sale\",\n            importance: 0.45\n        },\n        {\n            feature: \"proposal_consistency\",\n            importance: 0.40\n        }\n    ];\n    // Add variation based on selected model\n    let modelMultiplier = 1.0;\n    if (model === \"championship\") {\n        modelMultiplier = 1.02;\n    } else if (model === \"ceiling-breaker\") {\n        modelMultiplier = 0.98;\n    } else if (model === \"ultra-optimized\") {\n        modelMultiplier = 1.05;\n    }\n    return baseFeatures.map((item)=>({\n            ...item,\n            importance: Math.min(0.99, item.importance * modelMultiplier * (0.95 + Math.random() * 0.1))\n        }));\n};\nconst processData = async (trainData, testData, selectedModel)=>{\n    // Prepare data\n    const processedTrainData = prepareTrainingData(trainData);\n    const trainDataWithTarget = createTarget(processedTrainData);\n    // Calculate feature importance\n    const featureImportance = calculateFeatureImportance(selectedModel);\n    // Calculate model metrics\n    const metrics = getModelMetrics(selectedModel);\n    // Generate agent predictions\n    const agentPredictions = generateAgentPredictions(testData, selectedModel);\n    // Generate time series data\n    const timeSeriesData = generateTimeSeriesData(processedTrainData);\n    // Generate prediction distribution\n    const predictionDistribution = {\n        nill: agentPredictions.filter((a)=>a.predicted_nill === 1).length,\n        nonNill: agentPredictions.filter((a)=>a.predicted_nill === 0).length\n    };\n    // Generate conversion rates\n    const conversionRates = calculateConversionRates(processedTrainData);\n    // Generate agent performance data\n    const agentPerformance = calculateAgentPerformance(processedTrainData);\n    return {\n        metrics,\n        featureImportance,\n        agentPredictions,\n        timeSeriesData,\n        predictionDistribution,\n        conversionRates,\n        agentPerformance\n    };\n};\n// Helper functions for generating data\nfunction getModelMetrics(modelId) {\n    // Accuracy values based on model\n    let accuracy, precision, recall, f1Score;\n    switch(modelId){\n        case \"championship\":\n            accuracy = 0.918;\n            precision = 0.882;\n            recall = 0.865;\n            f1Score = 0.873;\n            break;\n        case \"ceiling-breaker\":\n            accuracy = 0.932;\n            precision = 0.903;\n            recall = 0.892;\n            f1Score = 0.898;\n            break;\n        case \"ultra-optimized\":\n            accuracy = 0.945;\n            precision = 0.916;\n            recall = 0.908;\n            f1Score = 0.912;\n            break;\n        default:\n            accuracy = 0.915;\n            precision = 0.88;\n            recall = 0.86;\n            f1Score = 0.87;\n    }\n    return {\n        accuracy,\n        precision,\n        recall,\n        f1Score,\n        atRiskCount: Math.floor(Math.random() * 50) + 200,\n        accuracyTrend: {\n            direction: \"up\",\n            value: \"+2.5%\",\n            positive: true\n        },\n        precisionTrend: {\n            direction: \"up\",\n            value: \"+1.8%\",\n            positive: true\n        },\n        recallTrend: {\n            direction: \"up\",\n            value: \"+3.2%\",\n            positive: true\n        },\n        atRiskTrend: {\n            direction: \"down\",\n            value: \"-5%\",\n            positive: true\n        }\n    };\n}\nfunction generateAgentPredictions(testData, modelId) {\n    if (!testData || testData.length === 0) {\n        return [];\n    }\n    // Model-specific risk threshold\n    let riskThreshold;\n    switch(modelId){\n        case \"championship\":\n            riskThreshold = 0.61;\n            break;\n        case \"ceiling-breaker\":\n            riskThreshold = 0.58;\n            break;\n        case \"ultra-optimized\":\n            riskThreshold = 0.55;\n            break;\n        default:\n            riskThreshold = 0.6;\n    }\n    return testData.map((row)=>{\n        // Calculate risk score based on available features\n        const proposalCount = parseFloat(row.unique_proposal) || 0;\n        const quotationCount = parseFloat(row.unique_quotations) || 0;\n        const activityRatio = quotationCount / Math.max(1, proposalCount);\n        const agentAge = parseFloat(row.agent_age) || 30;\n        // Calculate risk score with some randomness\n        let riskScore = (1 - activityRatio) * 0.4 + Math.max(0, (50 - agentAge) / 50) * 0.3 + Math.max(0, (20 - proposalCount) / 20) * 0.3;\n        // Add model-specific variation\n        if (modelId === \"championship\") {\n            riskScore *= 1.05;\n        } else if (modelId === \"ceiling-breaker\") {\n            riskScore *= 0.95;\n        } else if (modelId === \"ultra-optimized\") {\n            riskScore *= 0.9;\n        }\n        // Add some randomness\n        riskScore = Math.min(0.98, Math.max(0.1, riskScore + (Math.random() * 0.2 - 0.1)));\n        // Determine risk category\n        let riskCategory;\n        if (riskScore > 0.7) {\n            riskCategory = \"High\";\n        } else if (riskScore > 0.4) {\n            riskCategory = \"Medium\";\n        } else {\n            riskCategory = \"Low\";\n        }\n        // Generate prediction (0 = non-NILL, 1 = NILL)\n        const predictedNill = riskScore > riskThreshold ? 1 : 0;\n        // Generate top factors\n        const topFactors = [];\n        if (proposalCount < 15) topFactors.push(\"Low proposal count\");\n        if (activityRatio < 0.5) topFactors.push(\"Poor conversion ratio\");\n        if (agentAge < 25) topFactors.push(\"Young agent\");\n        if (agentAge > 55) topFactors.push(\"Senior agent\");\n        if (topFactors.length < 2) topFactors.push(\"Moderate activity\");\n        if (riskScore > 0.7) topFactors.push(\"Recent activity decline\");\n        // Generate personalized recommendation\n        let recommendation;\n        if (riskCategory === \"High\") {\n            recommendation = \"Immediate attention needed. Schedule a one-on-one coaching session focused on improving conversion rates and increasing proposal activity.\";\n        } else if (riskCategory === \"Medium\") {\n            recommendation = \"Regular monitoring required. Provide weekly targets and check-ins to maintain and improve performance.\";\n        } else {\n            recommendation = \"Continue with current approach. Consider as potential mentor for high-risk agents.\";\n        }\n        return {\n            agent_code: row.agent_code,\n            agent_age: agentAge,\n            months_with_company: parseFloat(row.months_with_company) || 0,\n            unique_proposal: proposalCount,\n            unique_quotations: quotationCount,\n            risk_score: riskScore,\n            predicted_nill: predictedNill,\n            risk_category: riskCategory,\n            top_factors: topFactors.slice(0, 3),\n            recommendation\n        };\n    });\n}\nfunction generateTimeSeriesData(trainData) {\n    // Group by month\n    const monthlyData = {};\n    trainData.forEach((row)=>{\n        if (!row.year_month) return;\n        const date = new Date(row.year_month);\n        const monthKey = \"\".concat(date.getFullYear(), \"-\").concat((date.getMonth() + 1).toString().padStart(2, \"0\"));\n        if (!monthlyData[monthKey]) {\n            monthlyData[monthKey] = {\n                month: monthKey,\n                avgPolicies: 0,\n                avgProposals: 0,\n                avgQuotations: 0,\n                nillRate: 0,\n                totalAgents: 0\n            };\n        }\n        monthlyData[monthKey].avgPolicies += row.new_policy_count || 0;\n        monthlyData[monthKey].avgProposals += row.unique_proposal || 0;\n        monthlyData[monthKey].avgQuotations += row.unique_quotations || 0;\n        monthlyData[monthKey].nillRate += row.new_policy_count === 0 ? 1 : 0;\n        monthlyData[monthKey].totalAgents += 1;\n    });\n    // Calculate averages\n    const timeSeriesData = Object.values(monthlyData).map((item)=>({\n            month: item.month,\n            avgPolicies: item.totalAgents > 0 ? item.avgPolicies / item.totalAgents : 0,\n            avgProposals: item.totalAgents > 0 ? item.avgProposals / item.totalAgents : 0,\n            avgQuotations: item.totalAgents > 0 ? item.avgQuotations / item.totalAgents : 0,\n            nillRate: item.totalAgents > 0 ? item.nillRate / item.totalAgents : 0\n        }));\n    // Sort by month\n    return timeSeriesData.sort((a, b)=>a.month.localeCompare(b.month));\n}\nfunction calculateConversionRates(trainData) {\n    // Calculate conversion rates by agent experience\n    const experienceGroups = {\n        \"new\": {\n            proposal_to_quotation: [],\n            quotation_to_policy: []\n        },\n        \"developing\": {\n            proposal_to_quotation: [],\n            quotation_to_policy: []\n        },\n        \"established\": {\n            proposal_to_quotation: [],\n            quotation_to_policy: []\n        },\n        \"veteran\": {\n            proposal_to_quotation: [],\n            quotation_to_policy: []\n        }\n    };\n    trainData.forEach((row)=>{\n        let expCategory;\n        const monthsWithCompany = row.months_with_company || 0;\n        if (monthsWithCompany <= 3) {\n            expCategory = \"new\";\n        } else if (monthsWithCompany <= 12) {\n            expCategory = \"developing\";\n        } else if (monthsWithCompany <= 24) {\n            expCategory = \"established\";\n        } else {\n            expCategory = \"veteran\";\n        }\n        const proposalToQuotation = row.unique_proposal > 0 ? row.unique_quotations / row.unique_proposal : 0;\n        const quotationToPolicy = row.unique_quotations > 0 ? row.new_policy_count / row.unique_quotations : 0;\n        experienceGroups[expCategory].proposal_to_quotation.push(proposalToQuotation);\n        experienceGroups[expCategory].quotation_to_policy.push(quotationToPolicy);\n    });\n    // Calculate averages\n    const conversionRates = Object.entries(experienceGroups).map((param)=>{\n        let [category, data] = param;\n        const avgProposalToQuotation = data.proposal_to_quotation.length > 0 ? data.proposal_to_quotation.reduce((sum, val)=>sum + val, 0) / data.proposal_to_quotation.length : 0;\n        const avgQuotationToPolicy = data.quotation_to_policy.length > 0 ? data.quotation_to_policy.reduce((sum, val)=>sum + val, 0) / data.quotation_to_policy.length : 0;\n        return {\n            category,\n            proposal_to_quotation: avgProposalToQuotation,\n            quotation_to_policy: avgQuotationToPolicy\n        };\n    });\n    return conversionRates;\n}\nfunction calculateAgentPerformance(trainData) {\n    // Group by experience level\n    const experienceLevels = [\n        {\n            label: \"0-3 months\",\n            min: 0,\n            max: 3\n        },\n        {\n            label: \"4-6 months\",\n            min: 4,\n            max: 6\n        },\n        {\n            label: \"7-12 months\",\n            min: 7,\n            max: 12\n        },\n        {\n            label: \"1-2 years\",\n            min: 13,\n            max: 24\n        },\n        {\n            label: \"2+ years\",\n            min: 25,\n            max: Infinity\n        }\n    ];\n    const performanceByExperience = experienceLevels.map((level)=>{\n        const agentsInLevel = trainData.filter((row)=>{\n            const months = row.months_with_company || 0;\n            return months >= level.min && months <= level.max;\n        });\n        // Calculate metrics\n        const totalAgents = agentsInLevel.length;\n        const avgPolicies = totalAgents > 0 ? agentsInLevel.reduce((sum, row)=>sum + (row.new_policy_count || 0), 0) / totalAgents : 0;\n        const nillAgents = agentsInLevel.filter((row)=>row.new_policy_count === 0).length;\n        const nillRate = totalAgents > 0 ? nillAgents / totalAgents : 0;\n        return {\n            experience: level.label,\n            avgPolicies,\n            nillRate: nillRate * 100,\n            totalAgents\n        };\n    });\n    return performanceByExperience;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9kYXRhUHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTZCO0FBRXRCLE1BQU1DLGNBQWMsT0FBT0M7SUFDaEMsSUFBSTtRQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUY7UUFDN0IsSUFBSSxDQUFDQyxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLGtCQUEyQixPQUFUSjtRQUNwQztRQUNBLE1BQU1LLFVBQVUsTUFBTUosU0FBU0ssSUFBSTtRQUNuQyxPQUFPQyxTQUFTRjtJQUNsQixFQUFFLE9BQU9HLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUFtQyxPQUFUUixVQUFTLE1BQUlRO1FBQ3JELE1BQU1BO0lBQ1I7QUFDRixFQUFFO0FBRUssTUFBTUQsV0FBVyxDQUFDRjtJQUN2QixNQUFNSyxVQUFVWixzREFBVSxDQUFDTyxTQUFTO1FBQ2xDTyxRQUFRO1FBQ1JDLGVBQWU7UUFDZkMsZ0JBQWdCO0lBQ2xCO0lBRUEsMEJBQTBCO0lBQzFCLElBQUlKLFFBQVFLLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7UUFDN0JQLFFBQVFRLElBQUksQ0FBQywyQkFBMkJQLFFBQVFLLE1BQU07SUFDeEQ7SUFFQSxPQUFPTCxRQUFRUSxJQUFJO0FBQ3JCLEVBQUU7QUFFSyxNQUFNQyxzQkFBc0IsQ0FBQ0M7SUFDbEMsdUJBQXVCO0lBQ3ZCLE1BQU1DLGNBQWM7UUFBQztRQUFvQjtRQUEyQjtLQUFhO0lBQ2pGLE1BQU1DLGdCQUFnQkYsVUFBVUcsR0FBRyxDQUFDQyxDQUFBQTtRQUNsQyxNQUFNQyxlQUFlO1lBQUUsR0FBR0QsR0FBRztRQUFDO1FBRTlCLHVDQUF1QztRQUN2Q0gsWUFBWUssT0FBTyxDQUFDQyxDQUFBQTtZQUNsQixJQUFJSCxHQUFHLENBQUNHLElBQUksRUFBRTtnQkFDWkYsWUFBWSxDQUFDRSxJQUFJLEdBQUcsSUFBSUMsS0FBS0osR0FBRyxDQUFD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QUEsSUFBSXlCLGdCQUFnQixJQUFJLElBQUksS0FBSzhFLGNBQWM7UUFFM0YsTUFBTXNCLGFBQWFGLGNBQWN6RSxNQUFNLENBQUNsRCxDQUFBQSxNQUFPQSxJQUFJeUIsZ0JBQWdCLEtBQUssR0FBR2pDLE1BQU07UUFDakYsTUFBTThHLFdBQVdDLGNBQWMsSUFBSXNCLGFBQWF0QixjQUFjO1FBRTlELE9BQU87WUFDTHVCLFlBQVlKLE1BQU1ILEtBQUs7WUFDdkJwQjtZQUNBRyxVQUFVQSxXQUFXO1lBQ3JCQztRQUNGO0lBQ0Y7SUFFQSxPQUFPa0I7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvZGF0YVByb2Nlc3Nvci5qcz9jMzk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSc7XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZENzdkZpbGUgPSBhc3luYyAoZmlsZVBhdGgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlUGF0aCk7XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgJHtmaWxlUGF0aH1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNzdlRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICByZXR1cm4gcGFyc2VDU1YoY3N2VGV4dCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgQ1NWIGZpbGUgJHtmaWxlUGF0aH06YCwgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQ1NWID0gKGNzdlRleHQpID0+IHtcclxuICBjb25zdCByZXN1bHRzID0gUGFwYS5wYXJzZShjc3ZUZXh0LCB7XHJcbiAgICBoZWFkZXI6IHRydWUsXHJcbiAgICBkeW5hbWljVHlwaW5nOiB0cnVlLFxyXG4gICAgc2tpcEVtcHR5TGluZXM6IHRydWVcclxuICB9KTtcclxuICBcclxuICAvLyBIYW5kbGUgYW55IHBhcnNlIGVycm9yc1xyXG4gIGlmIChyZXN1bHRzLmVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJDU1YgcGFyc2luZyBoYWQgZXJyb3JzOlwiLCByZXN1bHRzLmVycm9ycyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHRzLmRhdGE7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcHJlcGFyZVRyYWluaW5nRGF0YSA9ICh0cmFpbkRhdGEpID0+IHtcclxuICAvLyBDb252ZXJ0IGRhdGUgY29sdW1uc1xyXG4gIGNvbnN0IGRhdGVDb2x1bW5zID0gWydhZ2VudF9qb2luX21vbnRoJywgJ2ZpcnN0X3BvbGljeV9zb2xkX21vbnRoJywgJ3llYXJfbW9udGgnXTtcclxuICBjb25zdCBwcm9jZXNzZWREYXRhID0gdHJhaW5EYXRhLm1hcChyb3cgPT4ge1xyXG4gICAgY29uc3QgcHJvY2Vzc2VkUm93ID0geyAuLi5yb3cgfTtcclxuICAgIFxyXG4gICAgLy8gQ29udmVydCBkYXRlIHN0cmluZ3MgdG8gRGF0ZSBvYmplY3RzXHJcbiAgICBkYXRlQ29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XHJcbiAgICAgIGlmIChyb3dbY29sXSkge1xyXG4gICAgICAgIHByb2Nlc3NlZFJvd1tjb2xdID0gbmV3IERhdGUocm93W2NvbF0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZFJvdztcclxuICB9KTtcclxuICBcclxuICAvLyBTb3J0IGJ5IGFnZW50X2NvZGUgYW5kIHllYXJfbW9udGhcclxuICBwcm9jZXNzZWREYXRhLnNvcnQoKGEsIGIpID0+IHtcclxuICAgIGNvbnN0IGFDb2RlID0gU3RyaW5nKGEuYWdlbnRfY29kZSB8fCAnJyk7XHJcbiAgICBjb25zdCBiQ29kZSA9IFN0cmluZyhiLmFnZW50X2NvZGUgfHwgJycpOyAgXHJcbiAgICBcclxuICAgIGlmIChhQ29kZSA9PT0gYkNvZGUpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGEueWVhcl9tb250aCB8fCAwKSAtIG5ldyBEYXRlKGIueWVhcl9tb250aCB8fCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhQ29kZS5sb2NhbGVDb21wYXJlKGJDb2RlKTtcclxuICB9KTtcclxuICBcclxuICByZXR1cm4gcHJvY2Vzc2VkRGF0YTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVUYXJnZXQgPSAodHJhaW5EYXRhKSA9PiB7XHJcbiAgLy8gR3JvdXAgYnkgYWdlbnRfY29kZVxyXG4gIGNvbnN0IGFnZW50R3JvdXBzID0ge307XHJcbiAgdHJhaW5EYXRhLmZvckVhY2gocm93ID0+IHtcclxuICAgIGlmICghYWdlbnRHcm91cHNbcm93LmFnZW50X2NvZGVdKSB7XHJcbiAgICAgIGFnZW50R3JvdXBzW3Jvdy5hZ2VudF9jb2RlXSA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWdlbnRHcm91cHNbcm93LmFnZW50X2NvZGVdLnB1c2gocm93KTtcclxuICB9KTtcclxuICBcclxuICAvLyBTb3J0IGVhY2ggYWdlbnQncyBkYXRhIGJ5IHllYXJfbW9udGhcclxuICBPYmplY3QudmFsdWVzKGFnZW50R3JvdXBzKS5mb3JFYWNoKGFnZW50RGF0YSA9PiB7XHJcbiAgICBhZ2VudERhdGEuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS55ZWFyX21vbnRoKSAtIG5ldyBEYXRlKGIueWVhcl9tb250aCkpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIENyZWF0ZSB0YXJnZXQgdmFyaWFibGUgKDAgPSBOSUxMLCAxID0gbm9uLU5JTEwpXHJcbiAgY29uc3QgZGF0YVdpdGhUYXJnZXQgPSBbXTtcclxuICBPYmplY3QudmFsdWVzKGFnZW50R3JvdXBzKS5mb3JFYWNoKGFnZW50RGF0YSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFnZW50RGF0YS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgY29uc3QgY3VycmVudFJvdyA9IHsgLi4uYWdlbnREYXRhW2ldIH07XHJcbiAgICAgIGNvbnN0IG5leHRSb3cgPSBhZ2VudERhdGFbaSArIDFdO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgdGhleSBzZWxsIGFueXRoaW5nIG5leHQgbW9udGgsIHRhcmdldCBpcyAxIChub24tTklMTClcclxuICAgICAgY3VycmVudFJvdy50YXJnZXRfY29sdW1uID0gbmV4dFJvdy5uZXdfcG9saWN5X2NvdW50ID4gMCA/IDEgOiAwO1xyXG4gICAgICBkYXRhV2l0aFRhcmdldC5wdXNoKGN1cnJlbnRSb3cpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBkYXRhV2l0aFRhcmdldDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVGZWF0dXJlSW1wb3J0YW5jZSA9IChtb2RlbCkgPT4ge1xyXG4gIC8vIFNpbXVsYXRlIGZlYXR1cmUgaW1wb3J0YW5jZSBiYXNlZCBvbiBtb2RlbFxyXG4gIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBjb21lIGZyb20geW91ciBtb2RlbFxyXG4gIGNvbnN0IGJhc2VGZWF0dXJlcyA9IFtcclxuICAgIHsgZmVhdHVyZTogJ3VuaXF1ZV9wcm9wb3NhbCcsIGltcG9ydGFuY2U6IDAuODUgfSxcclxuICAgIHsgZmVhdHVyZTogJ3VuaXF1ZV9xdW90YXRpb25zJywgaW1wb3J0YW5jZTogMC43OCB9LFxyXG4gICAgeyBmZWF0dXJlOiAndW5pcXVlX3Byb3Bvc2Fsc19sYXN0XzdfZGF5cycsIGltcG9ydGFuY2U6IDAuNzIgfSxcclxuICAgIHsgZmVhdHVyZTogJ3VuaXF1ZV9xdW90YXRpb25zX2xhc3RfN19kYXlzJywgaW1wb3J0YW5jZTogMC42OSB9LFxyXG4gICAgeyBmZWF0dXJlOiAnYWdlbnRfYWdlJywgaW1wb3J0YW5jZTogMC42NSB9LFxyXG4gICAgeyBmZWF0dXJlOiAnbW9udGhzX3dpdGhfY29tcGFueScsIGltcG9ydGFuY2U6IDAuNjIgfSxcclxuICAgIHsgZmVhdHVyZTogJ3VuaXF1ZV9jdXN0b21lcnMnLCBpbXBvcnRhbmNlOiAwLjYxIH0sXHJcbiAgICB7IGZlYXR1cmU6ICd1bmlxdWVfY3VzdG9tZXJzX2xhc3RfN19kYXlzJywgaW1wb3J0YW5jZTogMC41OSB9LFxyXG4gICAgeyBmZWF0dXJlOiAncHJvcG9zYWxfbW9tZW50dW0nLCBpbXBvcnRhbmNlOiAwLjU4IH0sXHJcbiAgICB7IGZlYXR1cmU6ICdxdW90YXRpb25fY29udmVyc2lvbl9yYXRlJywgaW1wb3J0YW5jZTogMC41NSB9LFxyXG4gICAgeyBmZWF0dXJlOiAndW5pcXVlX3Byb3Bvc2Fsc19sYXN0XzE1X2RheXMnLCBpbXBvcnRhbmNlOiAwLjU0IH0sXHJcbiAgICB7IGZlYXR1cmU6ICd1bmlxdWVfcXVvdGF0aW9uc19sYXN0XzE1X2RheXMnLCBpbXBvcnRhbmNlOiAwLjUzIH0sXHJcbiAgICB7IGZlYXR1cmU6ICdoaXN0X25pbGxfcmF0ZScsIGltcG9ydGFuY2U6IDAuNTIgfSxcclxuICAgIHsgZmVhdHVyZTogJ2hpc3RfY3VycmVudF9uaWxsX3N0cmVhaycsIGltcG9ydGFuY2U6IDAuNDggfSxcclxuICAgIHsgZmVhdHVyZTogJ21vbnRoc190b19maXJzdF9zYWxlJywgaW1wb3J0YW5jZTogMC40NSB9LFxyXG4gICAgeyBmZWF0dXJlOiAncHJvcG9zYWxfY29uc2lzdGVuY3knLCBpbXBvcnRhbmNlOiAwLjQwIH1cclxuICBdO1xyXG4gIFxyXG4gIC8vIEFkZCB2YXJpYXRpb24gYmFzZWQgb24gc2VsZWN0ZWQgbW9kZWxcclxuICBsZXQgbW9kZWxNdWx0aXBsaWVyID0gMS4wO1xyXG4gIGlmIChtb2RlbCA9PT0gJ2NoYW1waW9uc2hpcCcpIHtcclxuICAgIG1vZGVsTXVsdGlwbGllciA9IDEuMDI7XHJcbiAgfSBlbHNlIGlmIChtb2RlbCA9PT0gJ2NlaWxpbmctYnJlYWtlcicpIHtcclxuICAgIG1vZGVsTXVsdGlwbGllciA9IDAuOTg7XHJcbiAgfSBlbHNlIGlmIChtb2RlbCA9PT0gJ3VsdHJhLW9wdGltaXplZCcpIHtcclxuICAgIG1vZGVsTXVsdGlwbGllciA9IDEuMDU7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBiYXNlRmVhdHVyZXMubWFwKGl0ZW0gPT4gKHtcclxuICAgIC4uLml0ZW0sXHJcbiAgICBpbXBvcnRhbmNlOiBNYXRoLm1pbigwLjk5LCBpdGVtLmltcG9ydGFuY2UgKiBtb2RlbE11bHRpcGxpZXIgKiAoMC45NSArIE1hdGgucmFuZG9tKCkgKiAwLjEpKVxyXG4gIH0pKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcm9jZXNzRGF0YSA9IGFzeW5jICh0cmFpbkRhdGEsIHRlc3REYXRhLCBzZWxlY3RlZE1vZGVsKSA9PiB7XHJcbiAgLy8gUHJlcGFyZSBkYXRhXHJcbiAgY29uc3QgcHJvY2Vzc2VkVHJhaW5EYXRhID0gcHJlcGFyZVRyYWluaW5nRGF0YSh0cmFpbkRhdGEpO1xyXG4gIGNvbnN0IHRyYWluRGF0YVdpdGhUYXJnZXQgPSBjcmVhdGVUYXJnZXQocHJvY2Vzc2VkVHJhaW5EYXRhKTtcclxuICBcclxuICAvLyBDYWxjdWxhdGUgZmVhdHVyZSBpbXBvcnRhbmNlXHJcbiAgY29uc3QgZmVhdHVyZUltcG9ydGFuY2UgPSBjYWxjdWxhdGVGZWF0dXJlSW1wb3J0YW5jZShzZWxlY3RlZE1vZGVsKTtcclxuICBcclxuICAvLyBDYWxjdWxhdGUgbW9kZWwgbWV0cmljc1xyXG4gIGNvbnN0IG1ldHJpY3MgPSBnZXRNb2RlbE1ldHJpY3Moc2VsZWN0ZWRNb2RlbCk7XHJcbiAgXHJcbiAgLy8gR2VuZXJhdGUgYWdlbnQgcHJlZGljdGlvbnNcclxuICBjb25zdCBhZ2VudFByZWRpY3Rpb25zID0gZ2VuZXJhdGVBZ2VudFByZWRpY3Rpb25zKHRlc3REYXRhLCBzZWxlY3RlZE1vZGVsKTtcclxuICBcclxuICAvLyBHZW5lcmF0ZSB0aW1lIHNlcmllcyBkYXRhXHJcbiAgY29uc3QgdGltZVNlcmllc0RhdGEgPSBnZW5lcmF0ZVRpbWVTZXJpZXNEYXRhKHByb2Nlc3NlZFRyYWluRGF0YSk7XHJcbiAgXHJcbiAgLy8gR2VuZXJhdGUgcHJlZGljdGlvbiBkaXN0cmlidXRpb25cclxuICBjb25zdCBwcmVkaWN0aW9uRGlzdHJpYnV0aW9uID0ge1xyXG4gICAgbmlsbDogYWdlbnRQcmVkaWN0aW9ucy5maWx0ZXIoYSA9PiBhLnByZWRpY3RlZF9uaWxsID09PSAxKS5sZW5ndGgsXHJcbiAgICBub25OaWxsOiBhZ2VudFByZWRpY3Rpb25zLmZpbHRlcihhID0+IGEucHJlZGljdGVkX25pbGwgPT09IDApLmxlbmd0aFxyXG4gIH07XHJcbiAgXHJcbiAgLy8gR2VuZXJhdGUgY29udmVyc2lvbiByYXRlc1xyXG4gIGNvbnN0IGNvbnZlcnNpb25SYXRlcyA9IGNhbGN1bGF0ZUNvbnZlcnNpb25SYXRlcyhwcm9jZXNzZWRUcmFpbkRhdGEpO1xyXG4gIFxyXG4gIC8vIEdlbmVyYXRlIGFnZW50IHBlcmZvcm1hbmNlIGRhdGFcclxuICBjb25zdCBhZ2VudFBlcmZvcm1hbmNlID0gY2FsY3VsYXRlQWdlbnRQZXJmb3JtYW5jZShwcm9jZXNzZWRUcmFpbkRhdGEpO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBtZXRyaWNzLFxyXG4gICAgZmVhdHVyZUltcG9ydGFuY2UsXHJcbiAgICBhZ2VudFByZWRpY3Rpb25zLFxyXG4gICAgdGltZVNlcmllc0RhdGEsXHJcbiAgICBwcmVkaWN0aW9uRGlzdHJpYnV0aW9uLFxyXG4gICAgY29udmVyc2lvblJhdGVzLFxyXG4gICAgYWdlbnRQZXJmb3JtYW5jZVxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBnZW5lcmF0aW5nIGRhdGFcclxuZnVuY3Rpb24gZ2V0TW9kZWxNZXRyaWNzKG1vZGVsSWQpIHtcclxuICAvLyBBY2N1cmFjeSB2YWx1ZXMgYmFzZWQgb24gbW9kZWxcclxuICBsZXQgYWNjdXJhY3ksIHByZWNpc2lvbiwgcmVjYWxsLCBmMVNjb3JlO1xyXG4gIFxyXG4gIHN3aXRjaCAobW9kZWxJZCkge1xyXG4gICAgY2FzZSAnY2hhbXBpb25zaGlwJzpcclxuICAgICAgYWNjdXJhY3kgPSAwLjkxODtcclxuICAgICAgcHJlY2lzaW9uID0gMC44ODI7XHJcbiAgICAgIHJlY2FsbCA9IDAuODY1O1xyXG4gICAgICBmMVNjb3JlID0gMC44NzM7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnY2VpbGluZy1icmVha2VyJzpcclxuICAgICAgYWNjdXJhY3kgPSAwLjkzMjtcclxuICAgICAgcHJlY2lzaW9uID0gMC45MDM7XHJcbiAgICAgIHJlY2FsbCA9IDAuODkyO1xyXG4gICAgICBmMVNjb3JlID0gMC44OTg7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAndWx0cmEtb3B0aW1pemVkJzpcclxuICAgICAgYWNjdXJhY3kgPSAwLjk0NTtcclxuICAgICAgcHJlY2lzaW9uID0gMC45MTY7XHJcbiAgICAgIHJlY2FsbCA9IDAuOTA4O1xyXG4gICAgICBmMVNjb3JlID0gMC45MTI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYWNjdXJhY3kgPSAwLjkxNTtcclxuICAgICAgcHJlY2lzaW9uID0gMC44ODtcclxuICAgICAgcmVjYWxsID0gMC44NjtcclxuICAgICAgZjFTY29yZSA9IDAuODc7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBhY2N1cmFjeSxcclxuICAgIHByZWNpc2lvbixcclxuICAgIHJlY2FsbCxcclxuICAgIGYxU2NvcmUsXHJcbiAgICBhdFJpc2tDb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTApICsgMjAwLCAvLyBSYW5kb20gY291bnQgYmV0d2VlbiAyMDAtMjUwXHJcbiAgICBhY2N1cmFjeVRyZW5kOiB7IGRpcmVjdGlvbjogJ3VwJywgdmFsdWU6ICcrMi41JScsIHBvc2l0aXZlOiB0cnVlIH0sXHJcbiAgICBwcmVjaXNpb25UcmVuZDogeyBkaXJlY3Rpb246ICd1cCcsIHZhbHVlOiAnKzEuOCUnLCBwb3NpdGl2ZTogdHJ1ZSB9LFxyXG4gICAgcmVjYWxsVHJlbmQ6IHsgZGlyZWN0aW9uOiAndXAnLCB2YWx1ZTogJyszLjIlJywgcG9zaXRpdmU6IHRydWUgfSxcclxuICAgIGF0Umlza1RyZW5kOiB7IGRpcmVjdGlvbjogJ2Rvd24nLCB2YWx1ZTogJy01JScsIHBvc2l0aXZlOiB0cnVlIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUFnZW50UHJlZGljdGlvbnModGVzdERhdGEsIG1vZGVsSWQpIHtcclxuICBpZiAoIXRlc3REYXRhIHx8IHRlc3REYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBcclxuICAvLyBNb2RlbC1zcGVjaWZpYyByaXNrIHRocmVzaG9sZFxyXG4gIGxldCByaXNrVGhyZXNob2xkO1xyXG4gIHN3aXRjaCAobW9kZWxJZCkge1xyXG4gICAgY2FzZSAnY2hhbXBpb25zaGlwJzpcclxuICAgICAgcmlza1RocmVzaG9sZCA9IDAuNjE7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnY2VpbGluZy1icmVha2VyJzpcclxuICAgICAgcmlza1RocmVzaG9sZCA9IDAuNTg7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAndWx0cmEtb3B0aW1pemVkJzpcclxuICAgICAgcmlza1RocmVzaG9sZCA9IDAuNTU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmlza1RocmVzaG9sZCA9IDAuNjtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHRlc3REYXRhLm1hcChyb3cgPT4ge1xyXG4gICAgLy8gQ2FsY3VsYXRlIHJpc2sgc2NvcmUgYmFzZWQgb24gYXZhaWxhYmxlIGZlYXR1cmVzXHJcbiAgICBjb25zdCBwcm9wb3NhbENvdW50ID0gcGFyc2VGbG9hdChyb3cudW5pcXVlX3Byb3Bvc2FsKSB8fCAwO1xyXG4gICAgY29uc3QgcXVvdGF0aW9uQ291bnQgPSBwYXJzZUZsb2F0KHJvdy51bmlxdWVfcXVvdGF0aW9ucykgfHwgMDtcclxuICAgIGNvbnN0IGFjdGl2aXR5UmF0aW8gPSBxdW90YXRpb25Db3VudCAvIE1hdGgubWF4KDEsIHByb3Bvc2FsQ291bnQpO1xyXG4gICAgY29uc3QgYWdlbnRBZ2UgPSBwYXJzZUZsb2F0KHJvdy5hZ2VudF9hZ2UpIHx8IDMwO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgcmlzayBzY29yZSB3aXRoIHNvbWUgcmFuZG9tbmVzc1xyXG4gICAgbGV0IHJpc2tTY29yZSA9IChcclxuICAgICAgKDEgLSBhY3Rpdml0eVJhdGlvKSAqIDAuNCArXHJcbiAgICAgIChNYXRoLm1heCgwLCAoNTAgLSBhZ2VudEFnZSkgLyA1MCkpICogMC4zICtcclxuICAgICAgKE1hdGgubWF4KDAsICgyMCAtIHByb3Bvc2FsQ291bnQpIC8gMjApKSAqIDAuM1xyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQWRkIG1vZGVsLXNwZWNpZmljIHZhcmlhdGlvblxyXG4gICAgaWYgKG1vZGVsSWQgPT09ICdjaGFtcGlvbnNoaXAnKSB7XHJcbiAgICAgIHJpc2tTY29yZSAqPSAxLjA1O1xyXG4gICAgfSBlbHNlIGlmIChtb2RlbElkID09PSAnY2VpbGluZy1icmVha2VyJykge1xyXG4gICAgICByaXNrU2NvcmUgKj0gMC45NTtcclxuICAgIH0gZWxzZSBpZiAobW9kZWxJZCA9PT0gJ3VsdHJhLW9wdGltaXplZCcpIHtcclxuICAgICAgcmlza1Njb3JlICo9IDAuOTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWRkIHNvbWUgcmFuZG9tbmVzc1xyXG4gICAgcmlza1Njb3JlID0gTWF0aC5taW4oMC45OCwgTWF0aC5tYXgoMC4xLCByaXNrU2NvcmUgKyAoTWF0aC5yYW5kb20oKSAqIDAuMiAtIDAuMSkpKTtcclxuICAgIFxyXG4gICAgLy8gRGV0ZXJtaW5lIHJpc2sgY2F0ZWdvcnlcclxuICAgIGxldCByaXNrQ2F0ZWdvcnk7XHJcbiAgICBpZiAocmlza1Njb3JlID4gMC43KSB7XHJcbiAgICAgIHJpc2tDYXRlZ29yeSA9ICdIaWdoJztcclxuICAgIH0gZWxzZSBpZiAocmlza1Njb3JlID4gMC40KSB7XHJcbiAgICAgIHJpc2tDYXRlZ29yeSA9ICdNZWRpdW0nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmlza0NhdGVnb3J5ID0gJ0xvdyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEdlbmVyYXRlIHByZWRpY3Rpb24gKDAgPSBub24tTklMTCwgMSA9IE5JTEwpXHJcbiAgICBjb25zdCBwcmVkaWN0ZWROaWxsID0gcmlza1Njb3JlID4gcmlza1RocmVzaG9sZCA/IDEgOiAwO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSB0b3AgZmFjdG9yc1xyXG4gICAgY29uc3QgdG9wRmFjdG9ycyA9IFtdO1xyXG4gICAgaWYgKHByb3Bvc2FsQ291bnQgPCAxNSkgdG9wRmFjdG9ycy5wdXNoKCdMb3cgcHJvcG9zYWwgY291bnQnKTtcclxuICAgIGlmIChhY3Rpdml0eVJhdGlvIDwgMC41KSB0b3BGYWN0b3JzLnB1c2goJ1Bvb3IgY29udmVyc2lvbiByYXRpbycpO1xyXG4gICAgaWYgKGFnZW50QWdlIDwgMjUpIHRvcEZhY3RvcnMucHVzaCgnWW91bmcgYWdlbnQnKTtcclxuICAgIGlmIChhZ2VudEFnZSA+IDU1KSB0b3BGYWN0b3JzLnB1c2goJ1NlbmlvciBhZ2VudCcpO1xyXG4gICAgaWYgKHRvcEZhY3RvcnMubGVuZ3RoIDwgMikgdG9wRmFjdG9ycy5wdXNoKCdNb2RlcmF0ZSBhY3Rpdml0eScpO1xyXG4gICAgaWYgKHJpc2tTY29yZSA+IDAuNykgdG9wRmFjdG9ycy5wdXNoKCdSZWNlbnQgYWN0aXZpdHkgZGVjbGluZScpO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBwZXJzb25hbGl6ZWQgcmVjb21tZW5kYXRpb25cclxuICAgIGxldCByZWNvbW1lbmRhdGlvbjtcclxuICAgIGlmIChyaXNrQ2F0ZWdvcnkgPT09ICdIaWdoJykge1xyXG4gICAgICByZWNvbW1lbmRhdGlvbiA9ICdJbW1lZGlhdGUgYXR0ZW50aW9uIG5lZWRlZC4gU2NoZWR1bGUgYSBvbmUtb24tb25lIGNvYWNoaW5nIHNlc3Npb24gZm9jdXNlZCBvbiBpbXByb3ZpbmcgY29udmVyc2lvbiByYXRlcyBhbmQgaW5jcmVhc2luZyBwcm9wb3NhbCBhY3Rpdml0eS4nO1xyXG4gICAgfSBlbHNlIGlmIChyaXNrQ2F0ZWdvcnkgPT09ICdNZWRpdW0nKSB7XHJcbiAgICAgIHJlY29tbWVuZGF0aW9uID0gJ1JlZ3VsYXIgbW9uaXRvcmluZyByZXF1aXJlZC4gUHJvdmlkZSB3ZWVrbHkgdGFyZ2V0cyBhbmQgY2hlY2staW5zIHRvIG1haW50YWluIGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLic7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWNvbW1lbmRhdGlvbiA9ICdDb250aW51ZSB3aXRoIGN1cnJlbnQgYXBwcm9hY2guIENvbnNpZGVyIGFzIHBvdGVudGlhbCBtZW50b3IgZm9yIGhpZ2gtcmlzayBhZ2VudHMuJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWdlbnRfY29kZTogcm93LmFnZW50X2NvZGUsXHJcbiAgICAgIGFnZW50X2FnZTogYWdlbnRBZ2UsXHJcbiAgICAgIG1vbnRoc193aXRoX2NvbXBhbnk6IHBhcnNlRmxvYXQocm93Lm1vbnRoc193aXRoX2NvbXBhbnkpIHx8IDAsXHJcbiAgICAgIHVuaXF1ZV9wcm9wb3NhbDogcHJvcG9zYWxDb3VudCxcclxuICAgICAgdW5pcXVlX3F1b3RhdGlvbnM6IHF1b3RhdGlvbkNvdW50LFxyXG4gICAgICByaXNrX3Njb3JlOiByaXNrU2NvcmUsXHJcbiAgICAgIHByZWRpY3RlZF9uaWxsOiBwcmVkaWN0ZWROaWxsLFxyXG4gICAgICByaXNrX2NhdGVnb3J5OiByaXNrQ2F0ZWdvcnksXHJcbiAgICAgIHRvcF9mYWN0b3JzOiB0b3BGYWN0b3JzLnNsaWNlKDAsIDMpLFxyXG4gICAgICByZWNvbW1lbmRhdGlvblxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVUaW1lU2VyaWVzRGF0YSh0cmFpbkRhdGEpIHtcclxuICAvLyBHcm91cCBieSBtb250aFxyXG4gIGNvbnN0IG1vbnRobHlEYXRhID0ge307XHJcbiAgXHJcbiAgdHJhaW5EYXRhLmZvckVhY2gocm93ID0+IHtcclxuICAgIGlmICghcm93LnllYXJfbW9udGgpIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHJvdy55ZWFyX21vbnRoKTtcclxuICAgIGNvbnN0IG1vbnRoS2V5ID0gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0keyhkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuICAgIFxyXG4gICAgaWYgKCFtb250aGx5RGF0YVttb250aEtleV0pIHtcclxuICAgICAgbW9udGhseURhdGFbbW9udGhLZXldID0ge1xyXG4gICAgICAgIG1vbnRoOiBtb250aEtleSxcclxuICAgICAgICBhdmdQb2xpY2llczogMCxcclxuICAgICAgICBhdmdQcm9wb3NhbHM6IDAsXHJcbiAgICAgICAgYXZnUXVvdGF0aW9uczogMCxcclxuICAgICAgICBuaWxsUmF0ZTogMCxcclxuICAgICAgICB0b3RhbEFnZW50czogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBtb250aGx5RGF0YVttb250aEtleV0uYXZnUG9saWNpZXMgKz0gcm93Lm5ld19wb2xpY3lfY291bnQgfHwgMDtcclxuICAgIG1vbnRobHlEYXRhW21vbnRoS2V5XS5hdmdQcm9wb3NhbHMgKz0gcm93LnVuaXF1ZV9wcm9wb3NhbCB8fCAwO1xyXG4gICAgbW9udGhseURhdGFbbW9udGhLZXldLmF2Z1F1b3RhdGlvbnMgKz0gcm93LnVuaXF1ZV9xdW90YXRpb25zIHx8IDA7XHJcbiAgICBtb250aGx5RGF0YVttb250aEtleV0ubmlsbFJhdGUgKz0gKHJvdy5uZXdfcG9saWN5X2NvdW50ID09PSAwKSA/IDEgOiAwO1xyXG4gICAgbW9udGhseURhdGFbbW9udGhLZXldLnRvdGFsQWdlbnRzICs9IDE7XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2VzXHJcbiAgY29uc3QgdGltZVNlcmllc0RhdGEgPSBPYmplY3QudmFsdWVzKG1vbnRobHlEYXRhKS5tYXAoaXRlbSA9PiAoe1xyXG4gICAgbW9udGg6IGl0ZW0ubW9udGgsXHJcbiAgICBhdmdQb2xpY2llczogaXRlbS50b3RhbEFnZW50cyA+IDAgPyBpdGVtLmF2Z1BvbGljaWVzIC8gaXRlbS50b3RhbEFnZW50cyA6IDAsXHJcbiAgICBhdmdQcm9wb3NhbHM6IGl0ZW0udG90YWxBZ2VudHMgPiAwID8gaXRlbS5hdmdQcm9wb3NhbHMgLyBpdGVtLnRvdGFsQWdlbnRzIDogMCxcclxuICAgIGF2Z1F1b3RhdGlvbnM6IGl0ZW0udG90YWxBZ2VudHMgPiAwID8gaXRlbS5hdmdRdW90YXRpb25zIC8gaXRlbS50b3RhbEFnZW50cyA6IDAsXHJcbiAgICBuaWxsUmF0ZTogaXRlbS50b3RhbEFnZW50cyA+IDAgPyBpdGVtLm5pbGxSYXRlIC8gaXRlbS50b3RhbEFnZW50cyA6IDBcclxuICB9KSk7XHJcbiAgXHJcbiAgLy8gU29ydCBieSBtb250aFxyXG4gIHJldHVybiB0aW1lU2VyaWVzRGF0YS5zb3J0KChhLCBiKSA9PiBhLm1vbnRoLmxvY2FsZUNvbXBhcmUoYi5tb250aCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVDb252ZXJzaW9uUmF0ZXModHJhaW5EYXRhKSB7XHJcbiAgLy8gQ2FsY3VsYXRlIGNvbnZlcnNpb24gcmF0ZXMgYnkgYWdlbnQgZXhwZXJpZW5jZVxyXG4gIGNvbnN0IGV4cGVyaWVuY2VHcm91cHMgPSB7XHJcbiAgICAnbmV3JzogeyBwcm9wb3NhbF90b19xdW90YXRpb246IFtdLCBxdW90YXRpb25fdG9fcG9saWN5OiBbXSB9LFxyXG4gICAgJ2RldmVsb3BpbmcnOiB7IHByb3Bvc2FsX3RvX3F1b3RhdGlvbjogW10sIHF1b3RhdGlvbl90b19wb2xpY3k6IFtdIH0sXHJcbiAgICAnZXN0YWJsaXNoZWQnOiB7IHByb3Bvc2FsX3RvX3F1b3RhdGlvbjogW10sIHF1b3RhdGlvbl90b19wb2xpY3k6IFtdIH0sXHJcbiAgICAndmV0ZXJhbic6IHsgcHJvcG9zYWxfdG9fcXVvdGF0aW9uOiBbXSwgcXVvdGF0aW9uX3RvX3BvbGljeTogW10gfVxyXG4gIH07XHJcbiAgXHJcbiAgdHJhaW5EYXRhLmZvckVhY2gocm93ID0+IHtcclxuICAgIGxldCBleHBDYXRlZ29yeTtcclxuICAgIGNvbnN0IG1vbnRoc1dpdGhDb21wYW55ID0gcm93Lm1vbnRoc193aXRoX2NvbXBhbnkgfHwgMDtcclxuICAgIFxyXG4gICAgaWYgKG1vbnRoc1dpdGhDb21wYW55IDw9IDMpIHtcclxuICAgICAgZXhwQ2F0ZWdvcnkgPSAnbmV3JztcclxuICAgIH0gZWxzZSBpZiAobW9udGhzV2l0aENvbXBhbnkgPD0gMTIpIHtcclxuICAgICAgZXhwQ2F0ZWdvcnkgPSAnZGV2ZWxvcGluZyc7XHJcbiAgICB9IGVsc2UgaWYgKG1vbnRoc1dpdGhDb21wYW55IDw9IDI0KSB7XHJcbiAgICAgIGV4cENhdGVnb3J5ID0gJ2VzdGFibGlzaGVkJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGV4cENhdGVnb3J5ID0gJ3ZldGVyYW4nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBwcm9wb3NhbFRvUXVvdGF0aW9uID0gcm93LnVuaXF1ZV9wcm9wb3NhbCA+IDAgPyByb3cudW5pcXVlX3F1b3RhdGlvbnMgLyByb3cudW5pcXVlX3Byb3Bvc2FsIDogMDtcclxuICAgIGNvbnN0IHF1b3RhdGlvblRvUG9saWN5ID0gcm93LnVuaXF1ZV9xdW90YXRpb25zID4gMCA/IHJvdy5uZXdfcG9saWN5X2NvdW50IC8gcm93LnVuaXF1ZV9xdW90YXRpb25zIDogMDtcclxuICAgIFxyXG4gICAgZXhwZXJpZW5jZUdyb3Vwc1tleHBDYXRlZ29yeV0ucHJvcG9zYWxfdG9fcXVvdGF0aW9uLnB1c2gocHJvcG9zYWxUb1F1b3RhdGlvbik7XHJcbiAgICBleHBlcmllbmNlR3JvdXBzW2V4cENhdGVnb3J5XS5xdW90YXRpb25fdG9fcG9saWN5LnB1c2gocXVvdGF0aW9uVG9Qb2xpY3kpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlc1xyXG4gIGNvbnN0IGNvbnZlcnNpb25SYXRlcyA9IE9iamVjdC5lbnRyaWVzKGV4cGVyaWVuY2VHcm91cHMpLm1hcCgoW2NhdGVnb3J5LCBkYXRhXSkgPT4ge1xyXG4gICAgY29uc3QgYXZnUHJvcG9zYWxUb1F1b3RhdGlvbiA9IGRhdGEucHJvcG9zYWxfdG9fcXVvdGF0aW9uLmxlbmd0aCA+IDAgPyBcclxuICAgICAgZGF0YS5wcm9wb3NhbF90b19xdW90YXRpb24ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIGRhdGEucHJvcG9zYWxfdG9fcXVvdGF0aW9uLmxlbmd0aCA6IDA7XHJcbiAgICBcclxuICAgIGNvbnN0IGF2Z1F1b3RhdGlvblRvUG9saWN5ID0gZGF0YS5xdW90YXRpb25fdG9fcG9saWN5Lmxlbmd0aCA+IDAgPyBcclxuICAgICAgZGF0YS5xdW90YXRpb25fdG9fcG9saWN5LnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyBkYXRhLnF1b3RhdGlvbl90b19wb2xpY3kubGVuZ3RoIDogMDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2F0ZWdvcnksXHJcbiAgICAgIHByb3Bvc2FsX3RvX3F1b3RhdGlvbjogYXZnUHJvcG9zYWxUb1F1b3RhdGlvbixcclxuICAgICAgcXVvdGF0aW9uX3RvX3BvbGljeTogYXZnUXVvdGF0aW9uVG9Qb2xpY3lcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGNvbnZlcnNpb25SYXRlcztcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlQWdlbnRQZXJmb3JtYW5jZSh0cmFpbkRhdGEpIHtcclxuICAvLyBHcm91cCBieSBleHBlcmllbmNlIGxldmVsXHJcbiAgY29uc3QgZXhwZXJpZW5jZUxldmVscyA9IFtcclxuICAgIHsgbGFiZWw6ICcwLTMgbW9udGhzJywgbWluOiAwLCBtYXg6IDMgfSxcclxuICAgIHsgbGFiZWw6ICc0LTYgbW9udGhzJywgbWluOiA0LCBtYXg6IDYgfSxcclxuICAgIHsgbGFiZWw6ICc3LTEyIG1vbnRocycsIG1pbjogNywgbWF4OiAxMiB9LFxyXG4gICAgeyBsYWJlbDogJzEtMiB5ZWFycycsIG1pbjogMTMsIG1heDogMjQgfSxcclxuICAgIHsgbGFiZWw6ICcyKyB5ZWFycycsIG1pbjogMjUsIG1heDogSW5maW5pdHkgfVxyXG4gIF07XHJcbiAgXHJcbiAgY29uc3QgcGVyZm9ybWFuY2VCeUV4cGVyaWVuY2UgPSBleHBlcmllbmNlTGV2ZWxzLm1hcChsZXZlbCA9PiB7XHJcbiAgICBjb25zdCBhZ2VudHNJbkxldmVsID0gdHJhaW5EYXRhLmZpbHRlcihyb3cgPT4ge1xyXG4gICAgICBjb25zdCBtb250aHMgPSByb3cubW9udGhzX3dpdGhfY29tcGFueSB8fCAwO1xyXG4gICAgICByZXR1cm4gbW9udGhzID49IGxldmVsLm1pbiAmJiBtb250aHMgPD0gbGV2ZWwubWF4O1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzXHJcbiAgICBjb25zdCB0b3RhbEFnZW50cyA9IGFnZW50c0luTGV2ZWwubGVuZ3RoO1xyXG4gICAgY29uc3QgYXZnUG9saWNpZXMgPSB0b3RhbEFnZW50cyA+IDAgPyBcclxuICAgICAgYWdlbnRzSW5MZXZlbC5yZWR1Y2UoKHN1bSwgcm93KSA9PiBzdW0gKyAocm93Lm5ld19wb2xpY3lfY291bnQgfHwgMCksIDApIC8gdG90YWxBZ2VudHMgOiAwO1xyXG4gICAgXHJcbiAgICBjb25zdCBuaWxsQWdlbnRzID0gYWdlbnRzSW5MZXZlbC5maWx0ZXIocm93ID0+IHJvdy5uZXdfcG9saWN5X2NvdW50ID09PSAwKS5sZW5ndGg7XHJcbiAgICBjb25zdCBuaWxsUmF0ZSA9IHRvdGFsQWdlbnRzID4gMCA/IG5pbGxBZ2VudHMgLyB0b3RhbEFnZW50cyA6IDA7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGV4cGVyaWVuY2U6IGxldmVsLmxhYmVsLFxyXG4gICAgICBhdmdQb2xpY2llcyxcclxuICAgICAgbmlsbFJhdGU6IG5pbGxSYXRlICogMTAwLCAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VcclxuICAgICAgdG90YWxBZ2VudHNcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIHBlcmZvcm1hbmNlQnlFeHBlcmllbmNlO1xyXG59Il0sIm5hbWVzIjpbIlBhcGEiLCJsb2FkQ3N2RmlsZSIsImZpbGVQYXRoIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJjc3ZUZXh0IiwidGV4dCIsInBhcnNlQ1NWIiwiZXJyb3IiLCJjb25zb2xlIiwicmVzdWx0cyIsInBhcnNlIiwiaGVhZGVyIiwiZHluYW1pY1R5cGluZyIsInNraXBFbXB0eUxpbmVzIiwiZXJyb3JzIiwibGVuZ3RoIiwid2FybiIsImRhdGEiLCJwcmVwYXJlVHJhaW5pbmdEYXRhIiwidHJhaW5EYXRhIiwiZGF0ZUNvbHVtbnMiLCJwcm9jZXNzZWREYXRhIiwibWFwIiwicm93IiwicHJvY2Vzc2VkUm93IiwiZm9yRWFjaCIsImNvbCIsIkRhdGUiLCJzb3J0IiwiYSIsImIiLCJhQ29kZSIsIlN0cmluZyIsImFnZW50X2NvZGUiLCJiQ29kZSIsInllYXJfbW9udGgiLCJsb2NhbGVDb21wYXJlIiwiY3JlYXRlVGFyZ2V0IiwiYWdlbnRHcm91cHMiLCJwdXNoIiwiT2JqZWN0IiwidmFsdWVzIiwiYWdlbnREYXRhIiwiZGF0YVdpdGhUYXJnZXQiLCJpIiwiY3VycmVudFJvdyIsIm5leHRSb3ciLCJ0YXJnZXRfY29sdW1uIiwibmV3X3BvbGljeV9jb3VudCIsImNhbGN1bGF0ZUZlYXR1cmVJbXBvcnRhbmNlIiwibW9kZWwiLCJiYXNlRmVhdHVyZXMiLCJmZWF0dXJlIiwiaW1wb3J0YW5jZSIsIm1vZGVsTXVsdGlwbGllciIsIml0ZW0iLCJNYXRoIiwibWluIiwicmFuZG9tIiwicHJvY2Vzc0RhdGEiLCJ0ZXN0RGF0YSIsInNlbGVjdGVkTW9kZWwiLCJwcm9jZXNzZWRUcmFpbkRhdGEiLCJ0cmFpbkRhdGFXaXRoVGFyZ2V0IiwiZmVhdHVyZUltcG9ydGFuY2UiLCJtZXRyaWNzIiwiZ2V0TW9kZWxNZXRyaWNzIiwiYWdlbnRQcmVkaWN0aW9ucyIsImdlbmVyYXRlQWdlbnRQcmVkaWN0aW9ucyIsInRpbWVTZXJpZXNEYXRhIiwiZ2VuZXJhdGVUaW1lU2VyaWVzRGF0YSIsInByZWRpY3Rpb25EaXN0cmlidXRpb24iLCJuaWxsIiwiZmlsdGVyIiwicHJlZGljdGVkX25pbGwiLCJub25OaWxsIiwiY29udmVyc2lvblJhdGVzIiwiY2FsY3VsYXRlQ29udmVyc2lvblJhdGVzIiwiYWdlbnRQZXJmb3JtYW5jZSIsImNhbGN1bGF0ZUFnZW50UGVyZm9ybWFuY2UiLCJtb2RlbElkIiwiYWNjdXJhY3kiLCJwcmVjaXNpb24iLCJyZWNhbGwiLCJmMVNjb3JlIiwiYXRSaXNrQ291bnQiLCJmbG9vciIsImFjY3VyYWN5VHJlbmQiLCJkaXJlY3Rpb24iLCJ2YWx1ZSIsInBvc2l0aXZlIiwicHJlY2lzaW9uVHJlbmQiLCJyZWNhbGxUcmVuZCIsImF0Umlza1RyZW5kIiwicmlza1RocmVzaG9sZCIsInByb3Bvc2FsQ291bnQiLCJwYXJzZUZsb2F0IiwidW5pcXVlX3Byb3Bvc2FsIiwicXVvdGF0aW9uQ291bnQiLCJ1bmlxdWVfcXVvdGF0aW9ucyIsImFjdGl2aXR5UmF0aW8iLCJtYXgiLCJhZ2VudEFnZSIsImFnZW50X2FnZSIsInJpc2tTY29yZSIsInJpc2tDYXRlZ29yeSIsInByZWRpY3RlZE5pbGwiLCJ0b3BGYWN0b3JzIiwicmVjb21tZW5kYXRpb24iLCJtb250aHNfd2l0aF9jb21wYW55Iiwicmlza19zY29yZSIsInJpc2tfY2F0ZWdvcnkiLCJ0b3BfZmFjdG9ycyIsInNsaWNlIiwibW9udGhseURhdGEiLCJkYXRlIiwibW9udGhLZXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1vbnRoIiwiYXZnUG9saWNpZXMiLCJhdmdQcm9wb3NhbHMiLCJhdmdRdW90YXRpb25zIiwibmlsbFJhdGUiLCJ0b3RhbEFnZW50cyIsImV4cGVyaWVuY2VHcm91cHMiLCJwcm9wb3NhbF90b19xdW90YXRpb24iLCJxdW90YXRpb25fdG9fcG9saWN5IiwiZXhwQ2F0ZWdvcnkiLCJtb250aHNXaXRoQ29tcGFueSIsInByb3Bvc2FsVG9RdW90YXRpb24iLCJxdW90YXRpb25Ub1BvbGljeSIsImVudHJpZXMiLCJjYXRlZ29yeSIsImF2Z1Byb3Bvc2FsVG9RdW90YXRpb24iLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJhdmdRdW90YXRpb25Ub1BvbGljeSIsImV4cGVyaWVuY2VMZXZlbHMiLCJsYWJlbCIsIkluZmluaXR5IiwicGVyZm9ybWFuY2VCeUV4cGVyaWVuY2UiLCJsZXZlbCIsImFnZW50c0luTGV2ZWwiLCJtb250aHMiLCJuaWxsQWdlbnRzIiwiZXhwZXJpZW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/dataProcessor.js\n"));

/***/ })

});